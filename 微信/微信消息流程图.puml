@startuml 微信单聊消息全流程
' 样式定义
skinparam activity {
  BackgroundColor #f9f9f9
  BorderColor #333333
  ArrowColor #0288d1
  StartColor #4caf50
  EndColor #f44336
  PartitionBorderColor #795548
  PartitionBackgroundColor #e0f2f1
}
skinparam note {
  BackgroundColor #fff3e0
  BorderColor #ff9800
}

|客户端A|
start
:1.用户输入消息内容;
:2.客户端封装消息体：
- 消息类型（文本/图片）
- 发送方/接收方ID
- 本地生成临时SeqID
- 消息创建时间戳;
:3.消息加密（TLS 1.3）：
- 端侧对称加密
- 附加设备签名;
:4.通过长连接发送：
- 检测长连接存活（心跳包）
- 连接异常则重连3次;
note right: 长连接保活机制：30s心跳包，超时则切换接入节点

|接入层 ConnectSvr|
:5.接收消息数据包;
:6.身份认证：
- 校验Token/会话密钥
- 验证设备合法性
- 非法则拒绝并记录日志;
:7.负载均衡路由：
- 根据接收方ID哈希分片
- 转发到对应逻辑层节点;
note left: ConnectSvr无状态，支持水平扩展

|逻辑层 SendSvr|
:8.消息基础校验：
- 黑名单/白名单过滤
- 消息长度/频率限流
- 反垃圾引擎初检;
:9.异常拦截：
- 校验失败→返回错误码给客户端A
- 触发风控告警（可选）;
if (校验通过?) then (是)
  :10.生成全局唯一标识：
  - 全局MsgID（分布式ID生成）
  - 会话级SeqID（递增）;
  :11.消息二次加密（服务端）：
  - 存储加密密钥
  - 附加服务端签名;
  |存储层 MsgStore|
  :12.消息持久化：
  - 写入主库（分片存储：按接收方ID）
  - 同步写入2个从库（容灾）
  - 缓存到Redis（会话最新消息）;
  note right: 先落地后投递，保证不丢消息
  :13.返回存储成功ACK（含全局MsgID/SeqID）;
  |逻辑层 SendSvr|
  :14.向客户端A返回"发送成功"响应;
  :15.触发投递事件：
  - 写入Kafka异步队列
  - 标记消息状态为"待投递";
  |推送层 PushSvr|
  :16.消费Kafka投递事件;
  :17.查询接收方B状态：
  - 从Redis读取ClientB在线状态
  - 关联ClientB当前ConnectSvr节点;
  if (ClientB在线?) then (是)
    |接入层 ConnectSvr(B)|
    :18.推送"消息到达通知"：
    - 仅携带MsgID/SeqID（轻量）
    - 不包含完整消息体;
    |客户端B|
    :19.接收到达通知;
    :20.主动拉取完整消息：
    - 携带已接收的最大SeqID
    - 避免重复拉取;
    |逻辑层 ReceiveSvr|
    :21.校验拉取权限：
    - 验证ClientB身份
    - 核对SeqID合法性;
    :22.从MsgStore读取消息：
    - 优先读Redis缓存
    - 缓存未命中则读数据库;
    :23.消息解密（服务端→客户端）;
    :24.返回完整消息体给ClientB;
  else (否)
    :18.触发离线推送：
    - 调用APNs（iOS）/FCM（Android）
    - 推送离线通知（仅标题+摘要）;
    |存储层 MsgStore|
    :19.标记消息为"未读-离线";
    note right: 离线消息保留7天，超期归档
    |客户端B|
    :20.客户端B上线后：
    - 主动拉取未读消息列表
    - 按SeqID补全缺失消息;
    goto 拉取完整消息步骤
  endif

  :25.ClientB解析消息体：
  - 解密消息内容
  - 渲染到聊天界面;
  :26.生成接收ACK：
  - 包含MsgID/SeqID
  - 标记"已接收"状态;
  :27.发送ACK到PushSvr;
  |推送层 PushSvr|
  :28.校验ACK合法性：
  - 核对SeqID连续性
  - 异常则触发消息补发;
  :29.更新消息状态：
  - MsgStore标记为"已送达"
  - Redis更新未读计数（清零）;
  note left: ACK确认机制：3次重试补发，超时标记为"投递失败"

  |多端同步模块|
  :30.同步消息状态到其他设备：
  - 推送SeqID更新事件
  - 多端拉取最新状态;
  |客户端A|
  :31.接收"对方已接收"回执（可选）;
  :32.本地更新消息状态：
  - 标记"已送达"
  - 同步到本地数据库;
else (否)
  |客户端A|
  :33.显示发送失败提示;
  :34.可选：本地缓存消息，待网络恢复重发;
endif

|客户端B|
:35.消息已读处理（可选）：
- 用户点击聊天会话
- 发送"已读"ACK到服务端;
:36.更新本地未读计数为0;

end
@enduml